# 20220212-Vue 响应式更新的原理

我写过几十篇源码分析类的文章，但从来没有写过和 Vue 有关的文章，原因是 Vue 源码分析的文章，实在是太多了。也从来没有专门花时间去看 Vue 源码，原因是当我使用 Vue 遇到问题的时候，百度都能解决。本科的时候用过 VB，读研的时候用过 Delphi，VB 和 Delphi 是上个世纪的开发工具，很多人都用过，在 VB 和 Delphi 中，响应式更新是一个非常普通非常自然的特性，就像空气和水一样。后来做了前端，响应式更新在前端圈竟然是一个非常热门的讨论方向，几乎面试必问，无语...。Delphi 1.0 是 1995 年，现在是 2022 年，我觉得 2022 年的前端编程语言和开发体验，比不上 1995 年的 Delphi。革命尚未成功，同志仍需努力。为了找工作，为了吃饭，我正式开启我的 Vue 源码之旅。

本文示例代码如下：

```html
<div id="app">
  {{ message }}
</div>
```

```JavaScript
const vm = new Vue({
  el: '#app',
  data: {
    message: 'inited'
  },
  beforeCreate() {
    console.log(this.message) // undefined
  },
  created() {
    console.log(this.message) // inited
  },
  watch: {
    message (val) {
      console.log('watch')
    }
  }
})

setTimeout(_ => {
    vm.message = 'changed'
}, 5000)
```

## 初始化阶段

初始化阶段包括给 data 添加 getter 和 setter、创建 Watcher 和 getter 内依赖收集。一切从 [Vue.prototype.init](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/init.js#L16) 开始，源码如下：

```JavaScript
Vue.prototype._init = function (options?: Object) {
  const vm: Component = this
  initLifecycle(vm)
  initEvents(vm)
  initRender(vm)
  // 调用 beforeCreate 生命周期函数
  callHook(vm, 'beforeCreate')
  initInjections(vm) // resolve injections before data/props
  // 在这里初始化 data、watch
  initState(vm)
  initProvide(vm) // resolve provide after data/props
  // 调用 created 生命周期函数
  callHook(vm, 'created')
  if (vm.$options.el) {
    vm.$mount(vm.$options.el)
  }
}
```

前天的面试，面试官问 Vue 的各个生命周期都做了什么，从 Vue.prototype.init 的源码可以看出，created 生命周期比 beforeCreate 生命周期多了 initInjections、initProvide 和 initState。在本文涉及的范围内，initState 的功能是初始化 Vue 构造函数传入的 data 属性和 watch 属性。initState [源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/state.js#L48)：

```JavaScript
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    // 初始化 data 属性
    initData(vm)
  }
  // 初始化 computed 属性，又一道面试题出现了
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    // 初始化 watch 属性
    initWatch(vm, opts.watch)
  }
}
```

### initData

initData [源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/state.js#L112)：

```JavaScript
function initData (vm: Component) {
  let data = vm.$options.data
  // vue 中 this.xxx 访问的对象是 vm._data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  const keys = Object.keys(data)
  let i = keys.length
  while (i--) {
    const key = keys[i]
    // 将 vue 中 this.xxx 的访问，代理到 _data 对象上
    proxy(vm, `_data`, key)
  }
  // 本文示例，这里 data 是 { message: 'inited' }
  // 响应式监测 data
  observe(data, true /* asRootData */)
}
```

在本文示例范围内，data 是 { message: 'inited' }，observe(data, true) 生成 data 的 Observer，也就是控制台中看到的 __ob__ 属性。observe 调用 Observer 构造函数，Observer 构造函数会做一些初始化的工作，然后调用 Observer.prototype.walk，遍历 data 的所有 key，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/index.js#L64)：

```JavaScript
walk (obj: Object) {
  const keys = Object.keys(obj)
  for (let i = 0; i < keys.length; i++) {
    // Vue 响应式更新的核心函数
    defineReactive(obj, keys[i])
  }
}
```

walk 调用 defineReactive，defineReactive 是 Vue 响应式更新最核心的函数，没有之一，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/index.js#L135)：

```JavaScript
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  // Vue 响应式更新最核心的变量，没有之一
  const dep = new Dep()
  // 本文示例，key 为 message
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      // Dep.target 是当前的 watcher
      if (Dep.target) {
        // 将 watcher 加入 dep
        dep.depend()
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      val = newVal
      // 有数据变更，通知 watcher
      dep.notify()
    }
  })
}
```

解释下 Dep 和 Watcher。

- Dep：一个管理 Vue 响应式的数据依赖的类，有字段 subs 存所以的 Watcher，可以添加删除 Watcher

- Watcher：有字段 cb 表示回调函数，在 Vue 响应式数据值有变动时会被调用。cb 可以是 Vue template 生成的渲染函数，也可以是前端开发者添加的 watch 回调函数。




### initWatch


## 运行时阶段



```JavaScript
var threeSum = function(nums) {
    nums = nums.sort((a, b) => a - b)
    let result = []
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] > 0) {
            break
        }
        // 答案去重 1，如 [-1, -1, -1, -1, 0, 1]
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue
        }
        let left = i + 1
        let right = nums.length - 1
        while(left < right) {
            if (nums[left] + nums[right] + nums[i] > 0) {
                right--
            } else if (nums[left] + nums[right] + nums[i] < 0) {
                left++
            } else {
                result.push([nums[i], nums[left], nums[right]])
                // 答案去重 2，如 [-2, 0, 0, 2, 2]
                while(nums[left] == nums[++left]);
                while(nums[right] == nums[--right]);
            }
        }
    }
    return result
};
```

## 参考

1.[Vue.js 技术揭秘](https://ustbhuangyi.github.io/vue-analysis/)

2.[Vue.js 中文文档](https://cn.vuejs.org/v2/guide/)



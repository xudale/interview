# 20220212-Vue 响应式更新的原理

我写过几十篇源码分析类的文章，但从来没有写过和 Vue 有关的文章，原因是 Vue 源码分析的文章，实在是太多了。也从来没有专门花时间去看 Vue 源码，原因是当我使用 Vue 遇到问题的时候，百度都能解决。本科的时候用过 VB，读研的时候用过 Delphi，VB 和 Delphi 是上个世纪的开发工具，很多人都用过，在 VB 和 Delphi 中，响应式更新是一个非常普通非常自然的特性，就像空气和水一样。后来做了前端，响应式更新在前端圈竟然是一个非常热门的讨论方向，几乎面试必问，无语...。Delphi 1.0 是 1995 年，现在是 2022 年，我觉得 2022 年的前端编程语言和开发体验，比不上 1995 年的 Delphi。革命尚未成功，同志仍需努力。为了找工作，为了吃饭，我正式开启我的 Vue 源码之旅。

本文示例代码如下：

```html
<div id="app">
  {{ message }}
</div>
```

```C++
const vm = new Vue({
  el: '#app',
  data: {
    message: 'inited'
  },
  beforeCreate() {
    console.log(this.message) // undefined
  },
  created() {
    console.log(this.message) // inited
  },
  watch: {
    message (val) {
      console.log('watch')
    }
  }
})

setTimeout(_ => {
    vm.message = 'changed'
}, 5000)
```

## Vue 实例初始化

初始化阶段包括给 data 添加 getter 和 setter、创建 Watcher 和 getter 内依赖收集。一切从 [Vue.prototype.init](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/init.js#L16) 开始，源码如下：

```C++
Vue.prototype._init = function (options?: Object) {
  const vm: Component = this
  initLifecycle(vm)
  initEvents(vm)
  initRender(vm)
  // 调用 beforeCreate 生命周期函数
  callHook(vm, 'beforeCreate')
  initInjections(vm) // resolve injections before data/props
  // 在这里初始化 data、watch
  initState(vm)
  initProvide(vm) // resolve provide after data/props
  // 调用 created 生命周期函数
  callHook(vm, 'created')
  if (vm.$options.el) {
    vm.$mount(vm.$options.el)
  }
}
```

前天的面试，面试官问 Vue 的各个生命周期都做了什么，从 Vue.prototype.init 的源码可以看出，created 生命周期比 beforeCreate 生命周期多了 initInjections、initProvide 和 initState。在本文涉及的范围内，initState 的功能是初始化 Vue 构造函数传入的 data 属性和 watch 属性。initState [源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/state.js#L48)：

```C++
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    // 初始化 data 属性
    initData(vm)
  }
  // 初始化 computed 属性，又一道面试题出现了
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    // 初始化 watch 属性
    initWatch(vm, opts.watch)
  }
}
```

### initData

initData [源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/state.js#L112)：

```C++
function initData (vm: Component) {
  let data = vm.$options.data
  // vue 中 this.xxx 访问的对象是 vm._data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  const keys = Object.keys(data)
  let i = keys.length
  while (i--) {
    const key = keys[i]
    // 将 vue 中 this.xxx 的访问，代理到 _data 对象上
    proxy(vm, `_data`, key)
  }
  // 本文示例，这里 data 是 { message: 'inited' }
  // 响应式监测 data
  observe(data, true /* asRootData */)
}
```

在本文示例范围内，data 是 { message: 'inited' }，observe(data, true) 生成 data 的 Observer，也就是控制台中看到的 __ob__ 属性。observe 调用 Observer 构造函数，Observer 构造函数会做一些初始化的工作，然后调用 Observer.prototype.walk，遍历 data 的所有 key，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/index.js#L64)：

```C++
walk (obj: Object) {
  const keys = Object.keys(obj)
  for (let i = 0; i < keys.length; i++) {
    // Vue 响应式更新的核心函数
    defineReactive(obj, keys[i])
  }
}
```

walk 调用 defineReactive，defineReactive 是 Vue 响应式更新最核心的函数，没有之一，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/index.js#L135)：

```C++
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  // Vue 响应式更新最核心的变量，没有之一
  const dep = new Dep()
  // 本文示例，key 为 message
  // obj 是 vm._data
  // vm.xxx 访问 vm._data.xxx
  // vm._data.xxx 访问这里的 getter
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      // Dep.target 是当前的 watcher
      if (Dep.target) {
        // 将 watcher 加入 dep
        dep.depend()
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      val = newVal
      // 有数据变更，通知 watcher
      dep.notify()
    }
  })
}
```

解释下 Dep 和 Watcher。

- Dep：一个管理 Vue 响应式的数据依赖的类，有字段 subs 存所以的 Watcher，可以添加删除 Watcher

- Watcher：有字段 cb 表示回调函数，在 Vue 响应式数据值有变动时会被调用。cb 可以是 Vue template 生成的渲染函数，也可以是前端开发者添加的 watch 回调函数。




### initWatch

initWatch 初始化 Vue 构造函数参数的 watch 属性，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/state.js#L290)：

```C++
function initWatch (vm: Component, watch: Object) {
  for (const key in watch) {
    const handler = watch[key]
    createWatcher(vm, key, handler)
  }
}
```

initWatch 遍历 watch 属性所以的 key，创建 Watcher，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/watcher.js#L45)：

```C++
export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    // expOrFn 是 message
    // cb 是 
    /** function message (val) {
      console.log('watch')
    }
    */
    this.vm = vm
    this.cb = cb
    this.id = ++uid // uid for batching
    this.deps = []
    // 创建一个可以读取 this.message 的函数
    this.getter = parsePath(expOrFn)
    this.value = this.lazy
      ? undefined
      : this.get()
  }
}
```

expOrFn 的值是 'message'，Watcher 观察的是 expOrFn 的值，需要读取 vm.message，this.getter = parsePath(expOrFn) 创建了一个可以读取 this.message 的方法，parsePath [源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/util/lang.js#L34)：

```C++
export function parsePath (path: string): any {
  // 按本文未例，path 是 'message'
  const segments = path.split('.')

  return function (obj) {
    // 按本文未例，以下四行的代码相当于 return obj.message
    for (let i = 0; i < segments.length; i++) {
      if (!obj) return
      obj = obj[segments[i]]
    }
    return obj
  }
}
```

parsePath 要考虑 watch 对象的层级较深，比如 'a.b.c' 的情况，所以代码稍微多了几行。按本文示例，parsePath 的功能相当于下面代码：

```C++
export function parsePath (path: string): any {
  return function (obj) {
    return obj.path
  }
}
```

现在已经有了可以获取 vm.message 的 getter，Watcher 最后一行调用了 this.get()，this.get 的功能是依赖收集，分三步：

- 将当前 Watcher 实例赋 Dep.target
- 调用 this.getter，相当于读取 vm.message
- 此时 defineReactive 中为 message 定义 getter 会被调用，在 getter 中，将 Dep.target 加入 dep
- defineReactive 中的闭包变量 dep 已经记录 message 发生改变时，需要通知的所有 Watcher 对象，依赖收集完成

，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/watcher.js#L101)：

```C++
/**
 * Evaluate the getter, and re-collect dependencies.
 */
get () {
  // 将
  pushTarget(this)
  let value
  const vm = this.vm
  try {
    value = this.getter.call(vm, vm)
  } catch (e) {} finally {
  }
  return value
}
```

get 调用 pushTarget，将当前 Watcher，赋值给 Dep.target。[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/dep.js#L58)：

```C++
export function pushTarget (target: ?Watcher) {
  targetStack.push(target)
  // Dep.target 存待收集的 Watcher 对象
  // 至于 Watcher 对象最后会被哪个 Dep 对象收集
  // 要看 defineReactive 中的 getter 调用情况
  Dep.target = target
}
```

value = this.getter.call(vm, vm)，相当于 value = vm.message。defineReactive 早已为 vm.message 定义了 getter，此时正式登场。defineReactive Vue 响应式最核心的代码，这里再贴一次：

```C++
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  // Vue 响应式更新最核心的变量，没有之一
  const dep = new Dep()
  // 本文示例，key 为 message
  // obj 是 vm._data
  // vm.xxx 访问 vm._data.xxx
  // vm._data.xxx 访问这里的 getter
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // this.getter.call(vm, vm) 导致了 message 的 getter 被调用
      // 代码从这里开始执行
      const value = getter ? getter.call(obj) : val
      // Dep.target 是当前待收集的 Watcher 对象
      if (Dep.target) {
        // 将 watcher 加入 dep
        dep.depend()
      }
      return value
    },
    set: function reactiveSetter (newVal) {
    }
  })
}
```

只看 getter 的代码，dep.depend() 把 Dep.target，也就是待收集的 Watcher 对象，收入囊中，(源码如下)[https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/dep.js#L23]：

```C++
depend () {
  if (Dep.target) {
    Dep.target.addDep(this)
  }
}

// 省略中间环节，dep.depend 最终会调用 dep.addSub，this.subs.push(Dep.target)
// 将待收集的 Watcher 对象，添加到 subs 数组
// subs: Array<Watcher>;
addSub (sub: Watcher) {
  this.subs.push(sub)
}
```

Dep 对象有字段 subs，声明是 subs: Array<Watcher>;存放依赖当前 Dep 对象的所以 Watcher。dep.depend 最终会调用 dep.addSub，将待收集的 Watcher，放入 subs 对象。依赖收集完成后，当 vm.message 的值有变化，Dep 对象会通知 subs 数组中全部 Watcher 对象，Watcher 对象调用自身的回调函数更新 UI，或者执行开发者添加的 watch 回调函数。

## 运行时


```C++
setTimeout(_ => {
  vm.message = 'changed'
}, 5000)
```

执行上面代码，改变 message 的值，defineReactive 中的 setter 会被调用，贴最后一次 defineReactive。


```C++
export function defineReactive (
) {
  const dep = new Dep()

  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {},
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      val = newVal
      // 有数据变更，通知 watcher
      dep.notify()
    }
  })
}
```

setter 里面调用 dep.notify()，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/dep.js#L37)：

```C++
notify () {
  // stabilize the subscriber list first
  const subs = this.subs.slice()
  for (let i = 0, l = subs.length; i < l; i++) {
    // subs[i] 是一个 Watcher 对象，update 调用后
    subs[i].update()
  }
}
```

subs[i].update 最终会调用 Watcher 对象的 run 方法，创建 Watcher 对象时，传给 Watcher 的回调函数终于被调用了，本文完。

```C++
run () {
  if (this.active) {
    const value = this.get()
    // set new value
    const oldValue = this.value
    this.value = value
    // Watcher 对象有个 cb 属性
    // 本文 cb 是
    // message (val) {
    //   console.log('watch')
    // }
    this.cb.call(this.vm, value, oldValue)
  }
}
```
## 总结

![defineReactive](https://raw.githubusercontent.com/xudale/interview/master/assets/defineReactive.jpeg)

## 参考

1.[Vue.js 技术揭秘](https://ustbhuangyi.github.io/vue-analysis/)

2.[Vue.js 中文文档](https://cn.vuejs.org/v2/guide/)



# 20220213-Vue数组响应式更新原理

失业期间目前面试 6 家，出现 4 次，出现概率 66.67%。

本文示例代码如下：

```html
<div id="app">
  {{ message }}
</div>
```

```C++
const vm = new Vue({
  el: '#app',
  data: {
    message: [1, 2]
  },
  watch: {
    message (val) {
      console.log('watch')
    }
  }
})

setTimeout(_ => {
	vm.message.push(3)
}, 5000)
```

Vue 数组响应式更新的原理和对象基本类似，分为 3 个阶段：

- 修改原型链，给数组添加变异方法
- 依赖收集
- 运行时调用数组变异方法


## 添加变异方法

故事从 [defineReactive](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/index.js#L135) 开始，源码如下：

```C++
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  // 本文示例 obj: { message: [1, 2] }
  // key: 'message'
  const dep = new Dep() // 它与本文无关，数组的 dep 不是它
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }
  // 走到这里，val: [1, 2]
  // 为 val 创建 Observer
  // childOb 是 child Observer，是数组的 Observer
  let childOb = !shallow && observe(val)
  // 本小节暂时看到这里吧
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          // 数组的依赖收集在这里
          childOb.dep.depend()
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      // 这里的代码，数组用不上
    }
  })
}
```

本文示例，val 是 [1, 2]，defineReactive 中的 observe(val) 为数组创建 Observer，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/index.js#L110)：


```C++
export function observe (value: any, asRootData: ?boolean): Observer | void {
  let ob: Observer | void
  // 本文示例 value: [1, 2]
  // 第一次进入 value 还没有相应的 Observer，走向 else if 分支
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (Array.isArray(value) {
  	// 走向这个分支
    ob = new Observer(value)
  }
  // 返回 Observer
  return ob
}
```

observe 判断之前有没有为 value 创建过 Observer，如果没有，创建 Observer，并将 Observer 对象 ob 返回给 defineReactive 的 childOb。Observer [源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/index.js#L37)：

```C++
export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
  	// 本文示例 value: [1, 2]
    this.value = value
    // 数组的 dep 在这里
    this.dep = new Dep()
    this.vmCount = 0
    // 添加 __ob__ 属性，表示数组已经有 Observer 了 
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
    	// 本文走这个分支
    	// 改变数组的原型
      protoAugment(value, arrayMethods)
    } else {
      this.walk(value)
    }
  }
}
```

Observer 构造函数创建了 Dep 实例，在本文示例的场景下，这个实例是数组的 Dep 实例，管理和数组相关的 Watcher。然后调用 protoAugment 改变数组的原型链，为数组添加变异方法。arrayMethods 表示数组的新原型，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/array.js#L6)：

```C++
const arrayProto = Array.prototype
// Vue 为数组添加的原型
export const arrayMethods = Object.create(arrayProto)

const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
]

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  // 在数组的新原型上，添加 7 个方法
  def(arrayMethods, method, function mutator (...args) {
  	// 调用数组的原生方法
    const result = original.apply(this, args)
    // 获取数组的 Observer
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    // 当新增数组元素时，为新增元素添加响应式更新
    if (inserted) ob.observeArray(inserted)
    // 通知 Watcher
    ob.dep.notify()
    return result
  })
})
```

arrayMethods 是 Vue 中数组的原型，它继承原生的数组原型，覆盖(override)了原生数组原型的 push、pop、shift、unshift、splice、sort 和 reverse 7 个方法。海淀某大厂面试，面试官问 Vue 数组有哪些变异方法，我答了 3 个，面试官叹了一口气。这道背诵题还是比较好背的，7 个方法分为两类：

- 改变数组元素个数：push、pop、shift、unshift、splice
- 改变数组元素顺序：sort、reverse

每个数组变异方法，都是先调用对应的原生数组方法，if (inserted) ob.observeArray(inserted) 对新增元素添加 setter 和 getter。最后 ob.dep.notify() 通知 Watcher 更新。前文有提过，数组的 __ob__ 属性是其 Observer 对象。

protoAugment 的逻辑是为数组设置新的原型 arrayMethods，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/index.js#L87)：

```C++
function protoAugment (target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}
```

本小节描述的是一个装孙子的过程，没有给 Vue 数组添加变异方法时：

```C++
vm.message.__proto__ == Array.prototype // true
```

添加完变异方法后：

```C++
vm.message.__proto__ == Array.prototype // false
vm.message.__proto__.__proto__ == Array.prototype // true
```

变异方法集成了 Vue 的触发更新逻辑。


## 依赖收集

渲染函数会读取 vm.message，defineReactive 中的 getter 会被调用，再贴一次 defineReactive。

```C++
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  // 本文示例 obj: { message: [1, 2] }
  // key: 'message'
  const dep = new Dep() // 它与本文无关，数组的 dep 不是它
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }
  // 走到这里，val: [1, 2]
  // 为 val 创建 Observer
  // childOb 是 child Observer，是数组的 Observer
  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
    	// 本小节从这里开始执行
    	// value 是 [1, 2]
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        // childOb 是是数组的 Observer
        if (childOb) {
          // Dep.target 是一个待收集的 Watcher 对象
          // childOb.dep 是数组 [1, 2] 的 Dep 对象
          // 在这里为数组添加 Watcher
          childOb.dep.depend()
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      // 这里的代码，数组用不上
    }
  })
}
```

childOb 是个闭包变量，表示数组 [1, 2] 的 Observer，其 dep 字段是 Dep 对象。在 getter 中访问 childOb，childOb.dep.depend() 添加数组的 Watcher。

## 运行时调用数组变异方法

```C++
setTimeout(_ => {
	vm.message.push(3)
}, 5000)
```

vm.message.push(3) 调用的是数组的变异方法，再贴一次变异方法源码：

```C++
methodsToPatch.forEach(function (method) {
  // cache original method
  const original = arrayProto[method]
  // 在数组的新原型上，添加 7 个方法
  def(arrayMethods, method, function mutator (...args) {
  	// 本文示例 method: push
  	// this: [1, 2]
  	// args: [3]
  	// 调用 Array.prototype.push.apply(this, [3])
    const result = original.apply(this, args)
    // 获取数组的 Observer
    const ob = this.__ob__
    let inserted
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args
        break
      case 'splice':
        inserted = args.slice(2)
        break
    }
    // 当新增数组元素时，为新增元素添加响应式更新
    if (inserted) ob.observeArray(inserted)
    // 通知 Watcher
    ob.dep.notify()
    return result
  })
})
```

在变异方法中 this 是数组 [1, 2]，args 是 [3]，ob = this.__ob__ 获取数组的 Observer 对象，最后 ob.dep.notify() 更新 Watcher。


## 盘点数组 Observer 的出现

本文大部分逻辑都围绕数组 [1, 2] 的 Observer 对象，下面盘点下其出现的地方。

第一次出现，Observer 创建完成后，childOb 是数组的 Observer 对象。

```C++
export function defineReactive () {
  const dep = new Dep() // 它与本文无关，数组的 dep 不是它
  // 走到这里，val: [1, 2]
  // 为 val 创建 Observer
  // childOb 是 child Observer，是数组的 Observer
  let childOb = !shallow && observe(val)
  // 删除定义 getter 的代码
}
```

第二次出现，Observer 构造函数，def(value, '__ob__', this)，数组的 __ob__ 字段是其 Observer 对象。

```C++
export class Observer {
  constructor (value: any) {
  	// 本文示例 value: [1, 2]
    this.value = value
    // 数组的 dep 在这里
    this.dep = new Dep()
    // 添加 __ob__ 属性，表示数组已经有 Observer 了 
    def(value, '__ob__', this)
    // 删除为数组改变原型的代码
  }
}
```

第三次出现，变异方法 ob = this.__ob__ 获取数组的 Observer 对象，ob.dep.notify() 通知 Watcher 更新。

```C++
methodsToPatch.forEach(function (method) {
  def(arrayMethods, method, function mutator (...args) {
  	// 本文示例 method: push
  	// this: [1, 2]
    // 获取数组的 Observer
    const ob = this.__ob__
    ob.dep.notify()
    return result
  })
})
```

s.watch)，初始化 watch 属性，依赖收集

### initData

initData [源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/state.js#L112)：

```C++
function initData (vm: Component) {
  let data = vm.$options.data
  // 本文示例 vm.xxx 访问的是 vm._data.xxx
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  const keys = Object.keys(data)
  let i = keys.length
  while (i--) {
    const key = keys[i]
    // 将形如 vm.xxx 的访问，代理到 vm._data 对象上
    proxy(vm, `_data`, key)
  }
  // 本文示例，data: { message: 'inited' }
  // 这 data，也就是 vm._data 添加响应式
  observe(data, true /* asRootData */)
}
```

在本文示例中，data 是 { message: 'inited' }，observe(data, true) 创建 data 的 Observer，也就是控制台中看到的 __ob__ 属性。observe 调用 Observer 构造函数，Observer 构造函数会做一些初始化的工作，然后调用 Observer.prototype.walk，遍历 data 对象的 key，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/index.js#L64)：

```C++
walk (obj: Object) {
  // 本文示例 obj: { message: 'inited' }
  const keys = Object.keys(obj)
  for (let i = 0; i < keys.length; i++) {
    // Vue 响应式更新最核心的函数
    defineReactive(obj, keys[i])
  }
}
```

walk 遍历 obj 的每一个 key，循环调用 defineReactive，defineReactive 是 Vue 响应式更新最核心的函数，没有之一，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/index.js#L135)：

```C++
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  // Vue 响应式更新最核心的变量，没有之一
  const dep = new Dep()
  // 本文示例 obj: vm._data，key: message
  // vm.xxx 访问 vm._data.xxx
  // vm._data.xxx 访问这里的 getter
  // 结合前两行
  // 最后产生的效果是 vm.xxx 访问了这里的 getter
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      // Dep.target 是当前的 watcher
      if (Dep.target) {
        // 将 watcher 加入 dep
        dep.depend()
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      // 如果值没变化，返回
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      val = newVal
      // 有数据变更，通知 watcher
      dep.notify()
    }
  })
}
```

解释下 Dep 和 Watcher：

- Dep：管理 Vue 响应式数据依赖的类，字段 subs 存依赖(本文示例中的 message)的 Watcher，可以添加删除 Watcher，驱动 Watcher 更新视图

- Watcher：字段 cb 表示回调函数，在 Vue 响应式数据的值有变动时调用。在本文中一共有两个 cb，第一个 Watcher 的 cb 是 Vue template 生成的渲染函数，第二个 Watcher 的 cb 是前端开发者添加的 watch 回调函数。


### initWatch

initWatch 初始化 Vue 构造函数参数的 watch 属性，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/state.js#L290)：

```C++
function initWatch (vm: Component, watch: Object) {
  // 本文示例
  // watch: {
  //   message (val) {
  //     console.log('watch')
  //   }
  // }
  for (const key in watch) {
    const handler = watch[key]
    createWatcher(vm, key, handler)
  }
}
```

initWatch 遍历 watch 属性所有的 key，本文示例的 watch 只有一个 key: 'message'。创建 Watcher，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/watcher.js#L45)：

```C++
export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    // 本文示例
    // expOrFn: message
    // cb: function message (val) {
    //   console.log('watch')
    // }
    this.vm = vm
    this.cb = cb
    this.id = ++uid // uid for batching
    this.deps = []
    // 创建一个可以读取 vm.message 的函数
    this.getter = parsePath(expOrFn)
    this.value = this.lazy
      ? undefined
      : this.get() // 开始依赖收集
  }
}
```

expOrFn 的值是 'message'，Watcher 观察的是 expOrFn 的值，需要读取 vm.message，this.getter = parsePath(expOrFn) 创建了一个可以读取 vm.message 的方法，parsePath [源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/util/lang.js#L34)：

```C++
export function parsePath (path: string): any {
  // 本文示例，path: 'message'
  const segments = path.split('.')
  return function (obj) {
    // 本文示例，以下四行的代码相当于 return obj.message
    for (let i = 0; i < segments.length; i++) {
      if (!obj) return
      obj = obj[segments[i]]
    }
    return obj
  }
}
```

parsePath 要考虑 watch 观察的属性是 'a.b.c' 的情况，所以代码稍微多了几行。在本文示例的场景下，parsePath 的功能相当于下面代码：

```C++
export function parsePath (path: string): any {
  return function (obj) {
    return obj.path
  }
}
```

现在已经有了可以获取 vm.message 的 getter，Watcher 最后一行调用了 this.get()，this.get 的功能是依赖收集，分四步：

- 将当前 Watcher 实例赋给全局变量 Dep.target
- 调用 this.getter，相当于读取 vm.message
- 此时 defineReactive 中为 message 设置 getter 被调用，在 getter 中，将 Dep.target 加入 dep
- defineReactive 中的闭包变量 dep 记录了所有观察 message 属性改变的 Watcher 对象，依赖收集完成

Watch.prototype.get [源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/watcher.js#L101)：

```C++
/**
 * Evaluate the getter, and re-collect dependencies.
 */
get () {
  // 将当前 Watcher 实例赋值给全局变量 Dep.target
  pushTarget(this)
  let value
  const vm = this.vm
  try {
    // 这里间接调用了 defineReactive 中的 getter，触发了依赖收集
    value = this.getter.call(vm, vm)
  } catch (e) {} finally {
  }
  return value
}
```

get 调用 pushTarget，将当前的 Watcher 对象，赋值给全局的 Dep.target，供 defineReactive 中的 getter 访问，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/dep.js#L58)：

```C++
export function pushTarget (target: ?Watcher) {
  targetStack.push(target)
  // Dep.target 存待收集的 Watcher 对象
  // 至于 Watcher 对象最后会被哪个 Dep 对象收集
  // 要看 defineReactive 中的 getter 调用情况
  Dep.target = target
}
```

value = this.getter.call(vm, vm)，相当于 value = vm.message。defineReactive 早已为 vm.message 定义了 getter，此时正式登场。defineReactive 是 Vue 响应式最核心的代码，这里再贴一次：

```C++
export function defineReactive (
) {
  // Vue 响应式更新最核心的变量，没有之一
  const dep = new Dep()
  Object.defineProperty(obj, key, {
    // 本文示例 key: message
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      // this.getter.call(vm, vm) 导致了 message 的 getter 被调用
      // 代码从这里开始执行
      const value = getter ? getter.call(obj) : val
      // Dep.target 是当前待收集的 Watcher 对象
      if (Dep.target) {
        // 将 watcher 加入 dep
        dep.depend()
      }
      return value
    },
    set: function reactiveSetter (newVal) {
    }
  })
}
```

getter 源码中，dep.depend() 把 Dep.target，也就是待收集的 Watcher 对象，收入囊中，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/dep.js#L23)：

```C++
depend () {
  if (Dep.target) {
    Dep.target.addDep(this)
  }
}

// 省略中间环节，dep.depend 最终会调用 dep.addSub，this.subs.push(Dep.target)
// 将待收集的 Watcher 对象，添加到 subs 数组
// subs 声明如下 subs: Array<Watcher>;
addSub (sub: Watcher) {
  this.subs.push(sub)
}
```

Dep 字段 subs，声明是 subs: Array<Watcher>。存储依赖当前 message 属性变化的所有 Watcher。dep.depend 最终会调用 dep.addSub，将待收集的 Watcher，放入 subs 数组中。依赖收集完成后，当 vm.message 的值有变化，Dep 对象会通知 subs 数组中的所有 Watcher 对象更新。Watcher 对象调用自身的 cb 字段，也就是回调函数。

## 运行时

```C++
setTimeout(_ => {
  vm.message = 'changed'
}, 5000)
```

5s 后，执行上面代码，改变 message 的值，defineReactive 中的 setter 会被调用，最后贴一次 defineReactive。


```C++
export function defineReactive (
) {
  const dep = new Dep()
  // 本文示例 key: message
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {},
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      val = newVal
      // 有数据变更，通知 watcher
      dep.notify()
    }
  })
}
```

setter 里面调用 dep.notify()，通知 Watcher 更新，[源码如下](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/dep.js#L37)：

```C++
notify () {
  // stabilize the subscriber list first
  const subs = this.subs.slice()
  for (let i = 0, l = subs.length; i < l; i++) {
    // subs[i] 是一个 Watcher 对象，update 调用后
    subs[i].update()
  }
}
```

subs[i].update 最终会调用 Watcher 对象的 [run](https://github.com/vuejs/vue/blob/v2.6.10/src/core/observer/watcher.js#L179) 方法。调用创建 Watcher 对象时，传给 Watcher 的回调函数 this.cb.call(this.vm, value, oldValue)。本文示例一共有两个 Watcher，第一个 Watcher 的 cb 是渲染函数，第二个 Watcher 的 cb 是开发都传入的 watch 对象，这两个 Watcher 的 cb 都会被调用。

```C++
run () {
  if (this.active) {
    const value = this.get()
    // set new value
    const oldValue = this.value
    this.value = value
    // Watcher 对象有个 cb 属性
    // 本文 cb 是
    // message (val) {
    //   console.log('watch')
    // }
    this.cb.call(this.vm, value, oldValue)
  }
}
```

本文的两个 Watcher 截图如下：

![twoWatcher](https://raw.githubusercontent.com/xudale/interview/master/assets/twoWatcher.png)


## 总结

![defineReactive](https://raw.githubusercontent.com/xudale/interview/master/assets/defineReactive.jpeg)

## 参考

1.[Vue.js 技术揭秘](https://ustbhuangyi.github.io/vue-analysis/)

2.[Vue.js 中文文档](https://cn.vuejs.org/v2/guide/)




# 20220124-实现深拷贝

基础版，考虑循环引用的问题。

```JavaScript
// 网上众多答案使用 WeakMap，我觉得本场景下，没必要用
function deepClone(obj, map = new Map()) {
	if (obj != null && typeof obj == 'object') {
		if (map.has(obj)) {
			return map.get(obj)
		} else {
			const clone = Array.isArray(obj) ? [] : {}
			map.set(obj, clone)
			return Object.keys(obj).reduce((result, key) => {
				result[key] = deepClone(obj[key], map)
				return result 
			}, clone)	
		}
		
	} else {
		return obj
	}
}

let obj = {val : 100, arr: [1,3]};
obj.self = obj
console.log(deepClone(obj))
```

进阶版。

```JavaScript
function deepClone(obj, map = new Map()) {
	if (obj instanceof Object) {
		if (map.has(obj)) {
			return map.get(obj)
		} else {
			let clone;
			if (obj instanceof Set) {
				clone = new Set()
				for (let key of obj) {
					clone.add(key)
				}
			} else if (obj instanceof Map) {
				clone = new Map()
				for (let [key, value] of obj) {
					clone.set(deepClone(key, map), deepClone(value, map))
				}
			} else if (obj instanceof Function) {
				clone = obj
			} else if (obj instanceof RegExp) {
				clone = new RegExp(obj)
			} else if (obj instanceof Array) {
				clone = new Array()
			} else if (obj instanceof Date) {
				clone = new Date(obj.valueOf())
			} else if (obj instanceof BigInt || obj instanceof Symbol || obj instanceof Number || obj instanceof String || obj instanceof Boolean) {
				clone = Object(obj.valueOf())
			} else {
				clone = {}
			}
			// 递规调用 deepClone 之前设置
			map.set(obj, clone);
			// 下面两行，任选一行
			Reflect.ownKeys(obj).forEach(key => {
			// [...Object.getOwnPropertyNames(obj), ...Object.getOwnPropertySymbols(obj)].forEach(key => {
				clone[key] = deepClone(obj[key], map)
			})
			return clone
		}
	} else {
		return obj
	}
}
```

测试代码：

```JavaScript
const objKey = {x: 'y'}
const set = new Set([1,objKey])
set.a = 3
const map = new Map([
	[3, 4],
	[objKey, 4],
	])
const array = [5,6]
const date = new Date()
const bigint = Object(2n)
bigint.a = 3
const symbol = Object(Symbol('3'))
const number = new Number(3)
const string = new String('4')
const boolean = new Boolean(true)
boolean.x = 33
boolean.y = console.log
boolean.z = /abc/g


let obj = {
	set,
	map,
	array,
	bigint,
	symbol,
	number,
	string,
	boolean,
	val : 100,
	b: 2n,
	s: Symbol('stu'),
	[Symbol('test')]: 34
};
obj.self = obj
console.log(deepClone(obj))
```

实现深拷贝，如果考虑所有细节，在面试过程中是不可能写完的。而且面试过程中也没有那么多时间对函数进行拆分，比如像 lodash 那样。所以，我觉得面试中的正确写法是先写框架：

```JavaScript
function deepClone(obj, map = new Map()) {
	if (obj instanceof Object) {
		if (map.has(obj)) {
			return map.get(obj)
		} else {
			let clone;
			// 后面慢慢补
			map.set(obj, clone);
			Reflect.ownKeys(obj).forEach(key => {
				clone[key] = deepClone(obj[key], map)
			})
			return clone
		}
	} else {
		return obj
	}
}
```

然后在框架中补上各个类型的特殊处理。如果不让用 deepClone，可以通过 Object.prototype.toString.call 获取类型。

```JavaScript
Object.prototype.toString.call(obj).slice(8, -1) // 'Object'
```

我在面试中遇到过 2-3 次深拷贝的问题，我感觉吧，这道题，我就从来没有答对过。一方面是自身能力问题，一方面是面试官出题语焉不详。只说深拷贝，拷贝规则又没有提。如果自己提到一些细节问要不要实现，面试官说要，但要是都实现的话呢，时间又不够。我觉得极个别面试官，其实也并没有考虑清楚深拷贝到底有哪些细节。所以，这实际是一道技术题 + 沟通题。

一些细节：

- Symbol 属性要不要拷贝(Object.getOwnPropertySymbols)
- 不可枚举属性要不要拷贝(Object.getOwnPropertyNames)
- key 的其它属性 configurable 和 writable，要不要拷贝(Object.getOwnPropertyDescriptor[s])，是不是得调用 Object.defineProperty 处理下
- key 已经被定义 setter/getter 的情况怎么办(Object.getOwnPropertyDescriptor[s])
- 把 Set/Map/Array/BigInt/Symbol 当对象使的情况下，如 set.a = 2，属性 a 要不要拷贝
- 如果要拷贝函数，可以用 new Function，最后正则匹配函数的 toString，但浏览器原生函数拷贝不了。如果不拷贝函数，func.a = 2，这个 a 要不要拷贝
- 拷贝用户自定义对象时，构造函数要不要调用，要是调用，参数怎么传
- 如果不调用构造函数，原型链要不要处理	
- Date/RegExp 要不要拷贝，尤其是 RegExp，拷贝了也没多大用处
- 还有其它类型：ArrayBuffer/Uint16ArrayUint32Array 等




















